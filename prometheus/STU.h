#pragma once
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'GameClientApp_dump_SCY.exetreated.exe'
*/

#include <Windows.h>
#include "idadefs.h"
#include "globals.h"
#include <set>
#include <stdexcept>
#include "game.h"

//rtti addresses
namespace STU_RTTI {
	//base Types
	const __int64 STUStatescriptGameEntry = 0x1766a50;
	const __int64 STUStatescriptState = 0x1766e40;
	const __int64 STUStatescriptCondition = 0x17669d0;
	const __int64 STUStatescriptActionTerminator = 0x1766c50;
	//Auch ein StatescriptState member
	const __int64 Unknown = 0x1766690;

	//Other inherits
	const __int64 STUConfigVarDynamic = 0x17909e0;
	const __int64 STUStatescriptOutputPlug = 0x1766bd0;
	const __int64 STUStatescriptStateUXBase = 0x1759fb0;

	const __int64 teStructuredData = 0x17a37b0;
};

//Name hashes
//_ suffixed means name unknown
namespace STU_NAME {
	const uint STUStatescriptOutputPlug = 0x3E490486;
	const uint STUStatescriptActionSetVar = 0x4698e4b6;
	const uint STUStatescriptStateBooleanSwitch = 0xe811ecbb;
	const uint STUStatescriptEntryGameMessage = 0xbe49a4c2;
	const uint STUConfigVarGameMessage = 0xff7876f9;
	const uint STUStatescriptStateUXScreen = 0xc739baac;
	const uint STUStatescriptStateUXBase = 0x8ba08edd;
	const uint STUStatescriptStateSubScript = 0x3db862c4;
	const uint STUStatescriptStateWait = 0x65f158da;
	const uint STUStatescriptInputPlug = 0x11d7f052;
	const uint STUStatescriptStateSwitch = 0x26367267;
	const uint STUStatescriptStateEffect = 0xffbfa88d;
	const uint STUStatescriptComponent = 0x9b38211b;
	const uint STUStatescriptStateUXHeroSelectScreen = 0x8F23FA30;
	const uint STUStatescriptStateLogicalButton = 0xff77458c;
	const uint STUConfigVarLogicalButton = 0x5c7964ff;
	const uint STUConfigVarExpression = 0xcc3a08f4;
	const uint STUStatescriptState = 0xa7213568;
	const uint STUStatescriptAction = 0x2ecefc8b;

	namespace Primitive {
		const uint32 teMtx43A = 0x6fb9880b;
		const uint32 teVec3A = 0x2357e676;
		const uint32 teVec2 = 0xf6ec8926;
		const uint32 teVec3 = 0x81ebb9b0;
		const uint32 teVec4 = 0x1f8f2c13;
		const uint32 teQuat = 0xda9494c8;
		const uint32 teColorRGB = 0x525114ab;
		const uint32 teColorRGBA = 0xa9e19537;
		const uint32 teStructuredDataDateAndTime = 0xe1b9e763;
		const uint32 teEntityID = 0xc525b48;

		const uint32 DBID = 0x20b3d5a9;
		const uint32 teUUID = 0x809899f3;
		const uint32 teString = 0xbbca304b;

		//s8 gibts nicht?
		const uint32 s16 = 0xa0119d30;
		const uint32 s32 = 0x954a3bab;
		const uint32 s64 = 0x15e6adb;

		const uint32 u8 = 0x3b9327d2;
		const uint32 u16 = 0xa49ce182;
		const uint32 u32 = 0x91c74719;
		const uint32 u64 = 0x5d31669;
		
		const uint32 f32 = 0x8fa75a30;
		const uint32 f64 = 0x1bb30b40;

		extern std::set<uint32> _all;

		inline int _primitive_size(uint32 primitive_hash) {
			switch (primitive_hash) {
			case STU_NAME::Primitive::u8:
				return 1;
			case STU_NAME::Primitive::u16:
			case STU_NAME::Primitive::s16:
				return 2;
			case STU_NAME::Primitive::u32:
			case STU_NAME::Primitive::f32:
			case STU_NAME::Primitive::s32:
			case STU_NAME::Primitive::teEntityID:
				return 4;
			case STU_NAME::Primitive::s64:
			case STU_NAME::Primitive::u64:
			case STU_NAME::Primitive::f64:
			case STU_NAME::Primitive::teVec2:
			case STU_NAME::Primitive::teStructuredDataDateAndTime:
				return 8;
			case STU_NAME::Primitive::teColorRGB:
				return 0xC;
			case STU_NAME::Primitive::teVec3:
			case STU_NAME::Primitive::teVec4:
			case STU_NAME::Primitive::teVec3A:
			case STU_NAME::Primitive::teQuat:
			case STU_NAME::Primitive::DBID:
			case STU_NAME::Primitive::teUUID:
			case STU_NAME::Primitive::teString:
			case STU_NAME::Primitive::teColorRGBA:
				return 0x10;
			case STU_NAME::Primitive::teMtx43A:
				return 0x40;
			default:
				return 0;
			}
		}
	};

	const uint STUAction_PlayEffect_ = 0x66b5f581;
	const uint STUAction_RandomFromBucket_ = 0x2501a4db;
	const uint STUAction_SendGameMsgConditional_ = 0x5bea9b4b;

	const uint Simple_Condition_ = 0xb1032daf;
	const uint Effect_To_Play_Var_ = 0x48663e64;

	//Constraint type names
	/*
	const uint OnBegin_Plug_ = 0xf1f0a36d;
	const uint Abort_Plug_ = 0xe51f3e8d;*/

	const uint Subgraph_Plug_ = 0x24ab1f0b; //All inherit from this
	const uint Subgraph_Plug_2_ = 0xb8f35b20;
	const uint ClientOnly_Subgraph_Plug_ = 0x5732771b;
	const uint ClientOnly_Subgraph_Plug_2_ = 0x26c93342;
	const uint ServerOnly_Subgraph_Plug_ = 0x4e5feee5;
	
	/*const uint Switch_Plugs_ = 0x57e931d8;
	const uint Transition_Plugs_ = 0x8f6c88d9;
	const uint UX_Plugs_ = 0xaf12fa9c;*/

	const uint STUConfigVar = 0xbfd9aadd;
	const uint STUConfigVarDynamic = 0xf8cc195d;
	const uint STUIdentifier = 0x34D7F9EE;
};

enum STUConstraintType {
	STU_ConstraintType_Primitive = 0x0,
	STU_ConstraintType_BSList_Primitive = 0x1, // List of values
	STU_ConstraintType_Object = 0x2,
	STU_ConstraintType_BSList_Object = 0x3,
	STU_ConstraintType_InlinedObject = 0x4,
	STU_ConstraintType_BSList_InlinedObject = 0x5, // List of values, not pointers
	STU_ConstraintType_Map = 0x7,
	STU_ConstraintType_Enum = 0x8, //has a size of 4
	STU_ConstraintType_BSList_Enum = 0x9,
	STU_ConstraintType_NonSTUResourceRef = 0xA,
	STU_ConstraintType_BSList_NonSTUResourceRef = 0xB,
	STU_ConstraintType_ResourceRef = 0xC,
	STU_ConstraintType_BSList_ResourceRef = 0xD, //inlined list von resourceref
};

inline std::string STU_ConstraintType_ToString(STUConstraintType type) {
	switch (type) {
	case STU_ConstraintType_Primitive:
		return "Primitive";
	case STU_ConstraintType_BSList_Primitive:
		return "List: Primitive";
	case STU_ConstraintType_Object:
		return "Object";
	case STU_ConstraintType_BSList_Object:
		return "List: Object";
	case STU_ConstraintType_InlinedObject:
		return "InlinedObject";
	case STU_ConstraintType_BSList_InlinedObject:
		return "List: InlinedObject";
	case STU_ConstraintType_Map:
		return "Map";
	case STU_ConstraintType_Enum:
		return "Enum";
	case STU_ConstraintType_BSList_Enum:
		return "List: Enum";
	case STU_ConstraintType_NonSTUResourceRef:
		return "NonSTUResourceRef";
	case STU_ConstraintType_BSList_NonSTUResourceRef:
		return "List: NonSTUResourceRef";
	case STU_ConstraintType_ResourceRef:
		return "ResourceRef";
	case STU_ConstraintType_BSList_ResourceRef:
		return "List: ResourceRef";
	default:
		return "Unknown: " + std::to_string(type);
	}
}

struct string_rep;
struct InheritanceInfo;
struct STUInfo;
struct STUArgumentInfo;
struct StatescriptStateWait;
struct STUEntityDefinition;
struct STUBase_vt;
struct STU_Object;

namespace STURegistryData {
	extern std::set<STUBase_vt*> vfptr_addresses;
	void initialize();
};

struct MisalignedResourceLoadEntry {
	__int64 resource_ptr;
	__int32 flags;
	__int32 field_C;
	__int64 resource_id;
	MisalignedResourceLoadEntry* hashlist_next;
	__int64 resource_load_entry; //NULL wenn geladen
	__int64 assetpackItem_backref; //NULL wenn geladen
	__int32 field_30;
	__int32 mutex;

	template <typename T>
	T* get_as() {
		return (T*)resource_ptr;
	}

	inline MisalignedResourceLoadEntry* align() {
		return (MisalignedResourceLoadEntry*)((__int64)this & 0xFFFFFFFFFFFFFFC0);
	}

	inline bool valid() {
		return align() != nullptr && (uint64_t)this != 0xFFFFFFFFFFFFFFFF;
	}
};

struct STUteString {
	struct STUString {
		uint hash;
		int len;
		char* buf;

		//copies value
		void set(const char* str) {
			if (buf && (__int64)buf != (globals::gameBase + 0x1454b48)) {
				ow_dealloc((__int64)buf);
			}
			buf = (char*)ow_memalloc(strlen(str));
			strcpy(buf, str);
			hash = stringHash(buf);
		}
	};

	union {
		string_rep* string_rep;
		STUString* string;
	};
	int string_type;

	const char* read() {
		switch (string_type) {
		case 0:
			return "invalid";
		case 1:
			return string_rep->get();
		case 2:
			return string->buf;
		}
	}

	void set(const char* new_value) {
		switch (string_type) {
		case 0:
			string = (STUteString::STUString*)ow_memalloc(sizeof(STUteString::STUString));
			string_type = 2;
			set(new_value);
			break;
		case 1:
			owassert(false);
			break;
		case 2:
			owassert(string);
			string->set(new_value);
			break;
		}
	}
};

struct STUBullshitListPtr {
	void* list_if_1;
	void* list_if_not_1;
};

template <typename T>
struct STUBullshitListFull {
	STUBullshitListPtr* list_ptr;
	//If flag is 1: list_if_1 is used, count is stored as a __int64 in list_if_not_1
	__int64 flag;

	int count() {
		owassert(list_ptr != nullptr);
		if (flag == 1)
			return (int)list_ptr->list_if_not_1;
		return (int)list_ptr->list_if_1;
	}
	T* list() {
		owassert(list_ptr != nullptr); //if this happens other code may be fucked
		if (flag == 1)
			return (T*)list_ptr->list_if_1;
		return (T*)list_ptr->list_if_not_1;
	}
	void set_count(int count) {
		if (flag == 1)
			(*(int*)&list_ptr->list_if_not_1) = count;
		(*(int*)&list_ptr->list_if_1) = count;
	}
	void set_list(void* list) {
		if (flag == 1)
			*(void**)&list_ptr->list_if_1 = list;
		*(void**)&list_ptr->list_if_not_1 = list;
	}
	int indexof(T item) {
		int cnt = count();
		for (int i = 0; i < cnt; i++)
			if (list()[i] == item)
				return i;
		return -1;
	}
	bool contains(T item) {
		int cnt = count();
		for (int i = 0; i < cnt; i++)
			if (list()[i] == item)
				return true;
		return false;
	}
	bool valid() {
		return !!list_ptr;
	}

	T* begin() {
		return &list()[0];
	}
	T* end() {
		return &list()[count()];
	}
};

//map value is an STU object ptr
template <typename T>
struct STUMapItem {
	uint key;
	T value;
};

template <typename T>
struct STUBullshitMapPtr {
	int count;
	int* map_unk; //size = count
	STUMapItem<T>* map;
};

//typ 1 == vodoolist???
//yo wtf
template <typename T>
struct STUBullshitMapFull {
	STUBullshitMapPtr<T>* list_ptr;
	//If flag is 1: list_if_1 is used, count is stored as a __int64 in list_if_not_1
	__int64 flag;

	int count() {
		if (flag != 2) {
			owassert(false);
			return 0;
		}
		if (!list_ptr->map_unk)
			return 0;
		return list_ptr->map_unk[list_ptr->count - 1]; //im crying 0xf17591
	}
	STUMapItem<T>* list() {
		if (flag != 2) {
			owassert(false);
			return 0;
		}
		return list_ptr->map;
	}
	STUMapItem<T>* get_by_key(uint key) {
		auto items = list();
		for (int i = 0; i < count(); i++) {
			if (items[i].key == key)
				return &items[i];
		}
	}
	/*int indexof(T item) {
		int cnt = count();
		for (int i = 0; i < cnt; i++)
			if (list()[i] == item)
				return i;
		return -1;
	}*/
	bool valid() {
		return list_ptr;
	}
};

/// Benützt bei allen value containern geladen aus CASC. Sollte die Basis für alle statescript sachen sein.
struct STUBase_vt
{
	void(__fastcall* SomeNullsub)();
	InheritanceInfo_destructor_vt rtti;
	STUInfo* const (__fastcall* GetSTUInfo)();
	__int64(__fastcall* proxy_get_something_from_arginfo)(__int64);
	__int64(__fastcall* proxy_get_something_from_arginfo_2)(__int64 stu);
	string_rep* (__fastcall* returns_nullstr_idk)(__int64, string_rep*);
	void(__fastcall* nullsub_1)();
	__int64* (__fastcall* proxy_get_something_from_arginfo_3)(__int64*);
	__int64(__fastcall* proxy_some_more_arginfo_shit)(__int64*, __int64);
	__int64 (*ret_0)();
	__int64 (*ret_0_1)();
	__int64 (*ret_0_2)();
	__int64 (*ret_0_3)();
	__int64 (*ret_0_4)();
	void(__fastcall* field_4)();
	void(__fastcall* field_5)();
	void(__fastcall* field_6)();
	__int64(__fastcall* field_A0)(__int64*);
	__int64 (*field_7)();
	void(__fastcall* field_8)();
	__int64 (*field_9)();
	void(__fastcall* field_10)();
	char (*ret_1_0)();
};

template <typename T = STUBase_vt>
struct STUBase {
	union {
		T* vfptr;
		STUBase_vt* vfptr_stubase;
	};

	STUBase<>* as_generic() {
		return (STUBase<>*)this;
	}

	bool valid() {
		return (uintptr_t)this != 0xFFFFFFFFFFFFFFFF &&
			this &&
			!IsBadReadPtr(this, 8) &&
			((__int64)vfptr_stubase - globals::gameBase) < globals::gameSize; /*&&
			STURegistryData::vfptr_addresses.find(vfptr) != STURegistryData::vfptr_addresses.end())*/
	}

	STU_Object to_editable();
};

struct STUConstraint;
struct STUConstrant_vt {
	union {
		STRUCT_PLACE_CUSTOM(get_namehash, 0x30, __int64(*get_stu_name_hash_with_x200000000)(STUConstraint*));
		STRUCT_PLACE_CUSTOM(get_name, 0x60, const char* (*get_name)(STUConstraint*));
	};
};

struct STUConstraint {
	STUConstrant_vt* vfptr;

	__int64 get_stu_type() {
		return vfptr->get_stu_name_hash_with_x200000000(this) & 0xFFFFFFFF;
	}

	STUConstraintType get_type_flag() {
		return (STUConstraintType)((vfptr->get_stu_name_hash_with_x200000000(this) >> 32) & 0xFFFFFFFF);
	}

	bool is_primitive() {
		return get_type_flag() == STU_ConstraintType_Primitive && STU_NAME::Primitive::_all.find(get_stu_type()) != STU_NAME::Primitive::_all.end();
	}

	bool is_list() {
		auto type = get_type_flag();
		return
			type == STU_ConstraintType_BSList_Primitive ||
			type == STU_ConstraintType_BSList_Object ||
			type == STU_ConstraintType_BSList_InlinedObject ||
			type == STU_ConstraintType_BSList_Enum ||
			type == STU_ConstraintType_BSList_ResourceRef ||
			type == STU_ConstraintType_BSList_NonSTUResourceRef;
	}
};

struct STUEnumValueDefinition {
	char* value_name;
	uint32 hash;
	__int64 value;
};

struct STUEnumDefinition {
	char* enum_name;
	uint32 enum_hash;
	STUEnumValueDefinition* values;
	int values_count;

	STUEnumValueDefinition* findValue(int value) {
		for (int i = 0; i < values_count; i++) {
			if (values[i].value == value)
				return &values[i];
		}
		return nullptr;
	}
};

struct STU_EnumRegistry {
	STU_EnumRegistry* next;
	STUEnumDefinition* def;
};

inline STU_EnumRegistry* STUEnumRegistry() {
	return *(STU_EnumRegistry**)(globals::gameBase + 0x18f7500);
}

inline STUEnumDefinition* STUFindEnum(uint32 hash) {
	STU_EnumRegistry* registry = STUEnumRegistry();
	while (registry) {
		if (registry->def && registry->def->enum_hash == hash)
			return registry->def;
		registry = registry->next;
	}
	return nullptr;
}

/* 490 */
//many field names are still unknown
//and many also seem to be unions :(
struct STUArgumentInfo
{
	union {
		char* name;
		STRUCT_MIN_SIZE(0xA0);
		STRUCT_PLACE(uint, name_hash, 8);
		STRUCT_PLACE(int, offset, 0xc);
		STRUCT_PLACE(STUConstraint*, constraint, 0x10);
		STRUCT_PLACE(__int32, field_18, 0x18);
		STRUCT_PLACE(__int32, field_1C, 0x1c);
		STRUCT_PLACE(__int64, field_20, 0x20);
		STRUCT_PLACE(__int32, doesnt_need_resetvalue, 0x28);
		STRUCT_PLACE(__int32, field_2C, 0x2C);
		STRUCT_PLACE(__int64, field_30, 0x30);
		STRUCT_PLACE(__int64, default_value_mby, 0x38);
		STRUCT_PLACE(__int64, field_40, 0x40);
		STRUCT_PLACE(__int64, field_48, 0x48);
		STRUCT_PLACE(__int32, field_50, 0x50);
		STRUCT_PLACE(__int32, field_54, 0x54);

		STRUCT_PLACE(__int64, field_60, 0x60);
		STRUCT_PLACE(__int64, field_68, 0x68);

		STRUCT_PLACE(__int32, field_70, 0x70);
		STRUCT_PLACE(__int32, field_74, 0x74);
		STRUCT_PLACE(__int32, field_78, 0x78);
		STRUCT_PLACE(__int32, field_7c, 0x7c);
		STRUCT_PLACE(__int32, field_80, 0x80);
		STRUCT_PLACE(__int32, field_84, 0x84);
		STRUCT_PLACE(__int32, field_88, 0x88);
	};
};

/* 434 */
struct STUInfo
{
	union {
		char* name_str;
		STRUCT_PLACE(InheritanceInfo*, rtti_info, 8);
		STRUCT_PLACE(STUInfo*, child, 0x10); //start of siblings, stu's that all have the same base_stu
		STRUCT_PLACE(STUInfo*, sibling, 0x18); //next item with same base_stu
		STRUCT_PLACE(STUInfo*, base_stu, 0x20);
		STRUCT_PLACE(STUArgumentInfo*, arguments, 0x28);
		STRUCT_PLACE(int, argument_count, 0x54);
		STRUCT_PLACE(uint, name_hash, 0x50);
		STRUCT_PLACE(int, instance_size, 0x5C);
		STRUCT_PLACE_CUSTOM(create_inst_fn, 0x40, STUBase<STUBase_vt>* (*create_instance_fn)());
		STRUCT_PLACE_CUSTOM(clear_instance_fn, 0x48, STUBase<STUBase_vt>*(*clear_instance_fn)(__int64));
		STRUCT_PLACE(int, is_array_if_0, 0x58);
	};

	struct ArgumentIterator {
	public:
		using iterator_category = std::forward_iterator_tag;
		using value_type = std::pair<STUInfo*, STUArgumentInfo*>;
		using difference_type = std::ptrdiff_t;

		ArgumentIterator(STUInfo* info) :
			_info(info),
			_include_parents(true),
			_current_pos(-1) {
			this->operator++();
		}
		ArgumentIterator() = default;

		ArgumentIterator& operator++() {
			_current_pos++;
			if (!_info)
				return *this;
			if (_info->argument_count <= _current_pos) {
				_info = _include_parents ? _info->base_stu : nullptr;
				_current_pos = -1;
				return this->operator++();
			}
			return *this;
		}

		ArgumentIterator operator++(int) {
			ArgumentIterator tmp = *this;
			++(*this);
			return tmp;
		}

		bool operator==(const ArgumentIterator& it) const {
			return this->_current_pos == it._current_pos && this->_info == it._info && this->_include_parents == it._include_parents;
		}

		value_type operator*() const {
			if (!_info)
				throw std::out_of_range("Empty iterator called!");
			if (_info->argument_count <= _current_pos)
				throw std::out_of_range("Iterator called on invalid position!");
			return { _info, &_info->arguments[_current_pos] };
		}
	private:
		STUInfo* _info;
		int _current_pos;
		bool _include_parents;
	};

	ArgumentIterator begin() {
		return ArgumentIterator(this);
	}
	ArgumentIterator end() {
		return ArgumentIterator(nullptr);
	}

	bool assignable_to_hash(__int64 assign) {
		STUInfo* stu = this;
		while (stu) {
			if (stu->name_hash == assign)
				return true;
			stu = stu->base_stu;
		}
		return false;
	}

	bool assignable_to_hashes(std::initializer_list<__int64> assign) {
		for (auto hash : assign) {
			if (assignable_to_hash(hash))
				return true;
		}
		return false;
	}

	//rva
	bool assignable_to_rtti(__int64 assign) {
		STUInfo* stu = this;
		while (stu) {
			if ((__int64)stu->rtti_info - globals::gameBase == assign)
				return true;
			stu = stu->base_stu;
		}
		return false;
	}

	bool assignable_to_rtti(InheritanceInfo* rtti) {
		STUInfo* stu = this;
		while (stu) {
			if (stu->rtti_info == rtti)
				return true;
			stu = stu->base_stu;
		}
		return false;
	}

	STUArgumentInfo* argumentByHash(uint hash, bool search_parents = true) {
		if (search_parents) {
			for (auto arg : *this) {
				if (arg.second->name_hash == hash)
					return arg.second;
			}
		}
		else {
			for (int i = 0; i < argument_count; i++) {
				if (arguments[i].name_hash == hash)
					return &arguments[i];
			}
		}
		return nullptr;
	}
};

struct STURegistry
{
	STURegistry* next;
	STUInfo* info;
};

struct STUResourceReference {
	MisalignedResourceLoadEntry* resource_load_entry;
	__int64 resource_id;

	bool is_resource_loaded() const {
		return *(uint64_t*)&resource_load_entry != 0xFFFFFFFFFFFFFFFFu && resource_load_entry->valid();
	}

	bool has_resource() const {
		return is_resource_loaded() || resource_id != 0;
	}

	const char* get_UXDisplayString() const {
		if (resource_id != 0)
			owassert((resource_id & 0xDE0000000000000) != 0);
		return GetUXDisplayString(resource_id);
	}

	STUBase<>* get_STU() const;
};

//struct EntityComponentMap {
//	__int64 component_hash; //Bsp 17c5e999 STUContactSetComponent
//	STUBase<>* STUEntityComponent_data;
//};
//
//struct ChildEntityDefinition {
//	__int64 unk;
//	STUResourceReference entity; //STUEntityDefinition*
//	STUResourceReference another_res_1;
//	STUResourceReference another_res_2;
//};
//
//typedef STUBullshitListFull<ChildEntityDefinition> ChildEntData;
//struct STUEntityDefinition {
//	union {
//		STUBase_vt* vfptr;
//		
//		STRUCT_PLACE(ChildEntData, m_childEntityData, 0x18);
//		STRUCT_PLACE(STUBullshitMapFull<EntityComponentMap>, m_componentMap, 0x28);
//	};
//};
//
////Alle IDs von Tracer
//struct STUHero {
//	union {
//		STUBase_vt* vfptr;
//		STRUCT_MIN_SIZE(0x180);
//		STRUCT_PLACE(STUResourceReference, f1_resource_reference, 0x8); //0F10000000000015
//		STRUCT_PLACE(STUResourceReference, m_gameplayEntity, 0x20);
//		STRUCT_PLACE(STUResourceReference*, hero_name, 0x30);
//		//STUSkinTheme ist was anderes 0A50000000001711
//		STRUCT_PLACE(STUBullshitListFull<STUResourceReference<__int64>>, m_skins, 0x40); //0AE00000000003EA
//		STRUCT_PLACE(STUResourceReference<__int64>, m_category, 0x50); //0D8000000000084E
//		
//		STRUCT_PLACE(STUBullshitListFull<STUResourceReference<__int64>>, d6_keys_list, 0x60); //0D600000000000F5
//		
//		STRUCT_PLACE(STUResourceReference<STUEntityDefinition>, entity_heroselect_lineup, 0x70); //Hero Lineup, HeroSelect
//		STRUCT_PLACE(STUResourceReference<STUEntityDefinition>, entity_herolineup, 0x80); //Hero Lineup, HeroSelect
//		STRUCT_PLACE(STUResourceReference<STUEntityDefinition>, entity_potg, 0x90); //POTG Scene
//
//		STRUCT_PLACE(STUResourceReference<__int64>, sound_state_1, 0xA0);
//		STRUCT_PLACE(STUResourceReference<__int64>, sound_state_2, 0xB0);
//		STRUCT_PLACE(STUResourceReference<__int64>, sound_state_3, 0xC0); //Hero Icon
//
//		STRUCT_PLACE(STUBullshitListFull<STUResourceReference<__int64>>, m_stats_list, 0xE0); //086000000000001F
//		//Loadout: 2x strings (Name, Description), STUInputLogicalButton, 0C00000000001310 (nicht STU)
//		STRUCT_PLACE(STUBullshitListFull<STUResourceReference<__int64>>, stu_loadout_array, 0xF0); //0B90000000000001 (4 bei tracer)
//		STRUCT_PLACE(STUResourceReference<__int64>, stu_progresstion_unlocks, 0x110)
//	};
//};

inline STURegistry* GetSTURegistry() {
	return *(STURegistry**)(globals::gameBase + 0x18f74e0);
}

inline STUInfo* GetSTUInfoByHash(int hash) {
	STURegistry* header = GetSTURegistry();
	while (header) {
		if (header->info->name_hash == hash)
			return header->info;
		header = header->next;
	}
	return nullptr;
}

//can return empty, not a resload-struct but getting already loaded resource ptr
inline __int64 try_load_resource(__int64 stu_id) {
	__try {
		auto load_ent2 = (__int64(__fastcall*)(__int64))(globals::gameBase + 0x9c6470);

		return load_ent2(stu_id);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		printf("Exception suppressd while loading resource %p!\n", stu_id);
	}
	return 0;
}

inline MisalignedResourceLoadEntry* try_load_resource_2(__int64 stu_id) {
	__try {
		typedef int (*fn)(MisalignedResourceLoadEntry**, __int64);
		fn resource_load = (fn)(globals::gameBase + 0x9c8330);

		MisalignedResourceLoadEntry* result_var;
		__int64 entity_def = resource_load(&result_var, stu_id);
		return result_var;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		printf("Exception suppressd while loading (2) resource %p!\n", stu_id);
	}
	return 0;
}